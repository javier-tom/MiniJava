/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
terminal DISPLAY;

/* keywords */
terminal CLASS, PUBLIC, STATIC, VOID, MAIN, NEW, IF, ELSE, TRUE, FALSE, WHILE;
terminal SOUT, THIS, EXTENDS, LENGTH, STRING_TYPE, INT, BOOLEAN;
terminal RETURN;

/* operators */
terminal PLUS, BECOMES, MINUS, TIMES, NOT, AND, LESS_THAN, DOT;

/* delimiters */
terminal LPAREN, RPAREN, SEMICOLON, LSQUARE, RSQUARE, LCURLY, RCURLY, COMMA;

/* identifiers */
terminal String IDENTIFIER;
terminal String INTEGER_LITERAL;


/* Nonterminals (constructed by parser): */

nonterminal Program Goal;
nonterminal MainClass MainClass;
nonterminal ClassDecl ClassDecl;
nonterminal ClassDeclList ClassDeclList;
nonterminal MethDecl MethDecl;
nonterminal MethDeclList MethDeclList;
nonterminal Formal Formal;
nonterminal FormalList FormalList;
nonterminal Statement Statement;
nonterminal StatementList StatementList;
nonterminal VarDecl VarDecl;
nonterminal VarDeclList VarDeclList;
nonterminal Type Type;
nonterminal Exp Expression;
nonterminal ExpList ExpressionList;
nonterminal Identifier Identifier;

/* Precedence declarations: */

precedence left PLUS, MINUS;
precedence left TIMES;
precedence left LESS_THAN;
precedence left AND;
precedence left NOT;



/* Productions: */

Goal ::= MainClass:mc ClassDeclList:cdl
    {: RESULT = new Program(mc, cdl, mcxleft); :};
MainClass ::= CLASS Identifier:id1 LCURLY PUBLIC STATIC VOID MAIN LPAREN STRING_TYPE LSQUARE RSQUARE
    Identifier:id2 RPAREN LCURLY Statement:s1 RCURLY RCURLY
    {: RESULT = new MainClass(id1, id2, s1, id1xleft); :};
ClassDecl ::= CLASS Identifier:id1 EXTENDS Identifier:id2 LCURLY VarDeclList:var_list MethDeclList:methdecl_list RCURLY
    {: RESULT = new ClassDeclExtends(id1, id2, var_list, methdecl_list, id1xleft); :}
    | CLASS Identifier:id1 LCURLY VarDeclList:var_list MethDeclList:methdecl_list RCURLY
    {: RESULT = new ClassDeclSimple(id1, var_list, methdecl_list, id1xleft); :};
ClassDeclList ::= ClassDeclList:cd_list ClassDecl:class
    {: cd_list.add(class);
       RESULT = cd_list; :}
    | {: RESULT = new ClassDeclList(new Location(0, 0)); :};
MethodDeclaration ::= PUBLIC Type:t Identifier:id LPAREN FormalList:formal_list RPAREN LCURLY VarDeclList:var_list
    StatementList:s_list RETURN Exp:exp SEMICOLON RCURLY
    {: RESULT = new MethodDecl(t, id, formal_list, var_list, s_list, exp, txleft); :}
    | Public Type:t Identifier:id LPAREN RPAREN LCURLY VarDeclList:var_list
    StatementList:s_list RETURN Exp:exp SEMICOLON RCURLY
    {: RESULT = new MethDecl(t, id, new FormalList(txleft), var_list, s_list, exp, txleft); :};
MethodDeclarationList ::= MethDeclList:methdecl_list MethDecl:method
    {: methdecl_list.add(method)
       RESULT = methdecl_list; :}
    | {: RESULT = new MethDeclList(new Location(0,0)); :};
VarDecl ::= Type:t Identifier:id SEMICOLON
    {: RESULT = new VarDecl(t, id, txleft); :};
VarDeclList ::= VarDeclList:var_list VarDecl:var
    {: var_list.add(var);
       Result = var_list; :}
    | {: Result = new VarDeclList(new Location(0,0)); :};
Formal ::= Type:t Identifier:id
    {: RESULT = new Formal(t, id, txleft); :};
FormalList ::= Formal:formal
    {: FormalList:formal_list = new FormalList(formalxleft);
       formal_list.add(formal);
       Result = formal_list; :}
    | FormalList:formal_list COMMA Formal:formal
    {: formal_list.add(formal);
       RESULT = formal_list; :};
Type ::= INT:i LSQUARE RSQUARE
            {: RESULT = new IntArrayType(ixleft); :}
        | BOOLEAN:b
            {: RESULT = new BooleanType(bxleft); :}
        | INT:i
            {: RESULT = new IntegerType(ixleft); :}
        | IDENTIFIER:id
            {: RESULT = new IdentifierType(id, idxleft); :};

Identifier ::= IDENTIFIER:i {: RESULT = new Identifier(i, ixleft); :};

StatementList ::= StatementList:sl Statement:s
        {: sl.add(s); RESULT = sl; :} |
        Statement:s {: StatementList sl = new StatementList(sxleft);
                       sl.add(s);
                       RESULT = sl; :};

Statement ::= LCURLY StatementList:sl RCURLY
        {: RESULT = new Block(sl, slxleft); :} |
    IF:i LPAREN Expression:e RPAREN Statement:s1 ELSE Statement:s2
        {: RESULT = new If(e, s1, s2, ixleft); :} |
    WHILE:w LPAREN Expression:e RPAREN Statement:s
        {: RESULT = new While(e, s, wxleft); :} |
    SOUT:s LPAREN Expression:e RPAREN SEMICOLON
        {: RESULT = new Print(e, sxleft); :} |
    Identifier:i BECOMES Expression:e SEMICOLON
        {: RESULT = new Assign(i, e, ixleft); :} |
    Identifier:i LSQUARE Expression:e1 RSQUARE BECOMES Expression:e2 SEMICOLON
        {: RESULT = new ArrayAssign(i, e1, e2, ixleft); :};

ExpressionList ::= ExpressionList:el Expression:e
        {: el.add(e); RESULT = el; :} |
    Expression:e {: ExpresionList el = new ExpressionList(exleft);
                    el.add(e);
                    RESULT = el; :};

Expression ::=
    Expression:e1 AND:a Expression:e2 {: RESULT = new And(e1, e2, axleft); :} |
    Expression:e1 LESS_THAN:a Expression:e2 {: RESULT = new LessThan(e1, e2, axleft); :} |
    Expression:e1 PLUS:a Expression:e2 {: RESULT = new Plus(e1, e2, axleft); :} |
    Expression:e1 MINUS:a Expression:e2 {: RESULT = new Minus(e1, e2, axleft); :} |
    Expression:e1 TIMES:a Expression:e2 {: RESULT = new Times(e1, e2, axleft); :} |
    Expression:e1 LSQUARE Expression:e2 RSQUARE
        {: RESULT = new ArrayLookup(e1, e2, e1xleft); :} |
    Expression:e DOT LENGTH
        {: RESULT = new ArrayLength(e, exleft); :} |
    Expression:e DOT Identifier:i LPAREN ExpressionList:el RPAREN
        {: RESULT = new Call(e, i, el, exleft); :} |
    INTEGER_LITERAL:i {: RESULT = new IntegerLiteral(Integer.parseInt(i), ixleft); :} |
    TRUE:t {: RESULT = new True(txleft); :} |
    FALSE:f {: RESULT = new False(fxleft); :} |
    Identifier:i {: RESULT = new IdentifierExp(i, ixleft); :} |
    THIS:t {: RESULT = new This(txleft); :} |
    NEW:n INT LSQUARE Expression:e RSQUARE
        {: RESULT = new NewArray(e, nxleft); :} |
    NEW:n Identifier:i LPAREN RPAREN {: RESULT = new NewObject(i, nxleft); :} |
    NOT:n Expression:e {: RESULT = new Not(e, nxleft); :} |
    LPAREN Expression:e RPAREN {: RESULT = e; :};